def reverse_fun_00101189(transformed_byte):
    # Try to reverse the transformations manually (using bitwise operations in reverse)
    for original_byte in range(256):
        if fun_00101189(original_byte) == transformed_byte:
            return original_byte
    return None  # If no match found, return None (shouldn't happen)

def fun_00101189(param_1):
    local_f = 0
    for local_c in range(8):
        local_f |= ((int((param_1 << 4) >> 6) | ((param_1 >> 4 | param_1 << 4) << 2)) >> (local_c & 0x1f) & 1) << (7 - (local_c & 0x1f))
    return local_f

# Example of encrypted data (from DAT_00102280)
encrypted = [
    0x0b, 0x7a, 0x19, 0x9a, 0x39, 0xb8, 0x58, 0xdb, 0xd9, 0x7b,
    0xc8, 0x30, 0x0b, 0x4b, 0x33, 0x88, 0xeb, 0x2b, 0x33, 0x0b,
    0xaa, 0x29, 0x33, 0xc8, 0x6a, 0xeb, 0x32, 0xc9, 0xeb, 0xa8,
    0x48, 0x32, 0xb2, 0xeb, 0x0b, 0x48, 0x33, 0xb2, 0xa8, 0xeb,
    0x32, 0xb2, 0xeb, 0x28, 0x29, 0x33, 0x0b, 0x32, 0x30, 0xaa,
    0xb2, 0xeb, 0xa8, 0x29, 0x33, 0xb0, 0xb2, 0xaa, 0x29, 0x33,
    0xfa, 0x00, 0x00, 0x00, 0x00
]

# Reverse the transformation for each byte
restored_data = [reverse_fun_00101189(byte) for byte in encrypted]
restored_password = ''.join(chr(byte) for byte in restored_data if byte is not None)

print(f"Restored password: {restored_password}")
